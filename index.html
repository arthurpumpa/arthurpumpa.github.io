<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>React</title>

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <section>
                <h3>Context</h3>
            </section>
            <section>
                <p>
                    With React, it’s easy to track the flow of data through your React components.
                    When you look at a component, you can see which props are being passed, which makes your apps easy
                    to reason about.
                </p>

            </section>
            <section>
                <p>
                    In some cases, you want to pass data through the component tree without having to pass the props
                    down manually at every level.
                    You can do this directly in React with the powerful “context” API.
                </p>
            </section>
            <section>
                <h2>Why Not To Use Context</h2>
            </section>
            <section>
                <script src="https://gist.github.com/staparix/fc586ff024bc5f8e4a22c2222239f48f.js"></script>
            </section>
        </section>

        <section>
            <section>
                <h2>Higher order Components (HOC)</h2>
            </section>
            <section>
                <h2>What are Higher Order Components?</h2>
                <p>A Higher Order Component is just a React Component that wraps another one.</p>
            </section>
            <section>
                <h2>What can I do with HOCs?</h2>
                <ul>
                    <li>Code reuse,logic and bootstrap abstraction</li>
                    <li>State abstraction and manipulation</li>
                    <li>Props manipulation</li>
                </ul>
            </section>
            <section>
                <h2>How do we implement HOC?</h2>
            </section>
            <section>
                <h3>Props Proxy (PP) </h3>
                <script src="https://gist.github.com/f0zze/ed732c843d72894362b69aa26171e160.js"></script>
            </section>
            <section>
                <h3>What can be done with Props Proxy?</h3>
                <ul>
                    <li>Manipulating props</li>
                    <li>Accessing the instance via Refs</li>
                    <li>Abstracting State</li>
                    <li>Wrapping the WrappedComponent with other elements</li>
                </ul>
            </section>
            <section>
                <h3>Manipulating props</h3>
                <p>
                    You can read, add, edit and remove the props that are being passed to the WrappedComponent.
                </p>
                <p>
                    <script src="https://gist.github.com/f0zze/31fa135610a21c6604c89b51c3ea77a5.js"></script>
                </p>
            </section>
            <section>
                <h3>Accessing the instance via Refs</h3>
                <p>You can access this (the instance of the WrappedComponent) with a ref</p>
                <p>
                    <script src="https://gist.github.com/f0zze/fcfc4a260f755e5bbeae70b66e7cef84.js"></script>
                </p>
                <small>This can be used for reading/adding instance props and to call instance methods.</small>
            </section>
            <section>
                <h3>State abstraction</h3>
                <p>You can abstract state by providing props and callbacks to the WrappedComponent</p>
            </section>
            <section>
                <script src="https://gist.github.com/f0zze/737383ab14c7d14fd83ff22627ac2803.js"></script>
            </section>
            <section>
                <script src="https://gist.github.com/f0zze/ae95056ca37852a442a1d47664d4501f.js"></script>
            </section>
            <section>
                <h3>Wrapping the WrappedComponent with other elements</h3>
                <p>
                    You can wrap the WrappedComponent with other components and elements for styling, layout or other
                    purposes.
                </p>
            </section>
            <section>
                <script src="https://gist.github.com/f0zze/a53cac3a360d819c365eda7f23038b47.js"></script>
            </section>
            <section>
                <h3>Inheritance Inversion</h3>
                <p>
                    <script src="https://gist.github.com/f0zze/0d4068c4f3f3c85b133321adcf81ee22.js"></script>
                </p>
            </section>
            <section>
                <p>
                    Inheritance Inversion allows the HOC to have access to the WrappedComponent instance via this,
                    which means it has access to the state, props, component lifecycle hooks and the render method.
                </p>
            </section>
            <section>
                <p>
                    Inheritance Inversion High Order Components don’t have a guaranty of having the full children tree
                    resolved.
                </p>
            </section>
            <section>
                <h3>What can you do with Inheritance Inversion?</h3>
                <ul>
                    <li>Render Highjacking</li>
                    <li>Manipulating state</li>
                </ul>
            </section>
            <section>
                <h3>Render Highjacking</h3>
                <p>
                    It is called Render Highjacking because the HOC takes control of the render output of the
                    WrappedComponent and can do all sorts of stuff with it.
                </p>
            </section>
            <section>
                <h3>In Render Highjacking you can:</h3>
                <ul>
                    <li>Read, add, edit, remove props in any of the React Elements outputted by render</li>
                    <li>Read, and modify the React Elements tree outputted by render</li>
                    <li>Conditionally display the elements tree</li>
                    <li>Wrapping the element’s tree for styling purposes (as shown in Props Proxy)</li>
                </ul>
            </section>
            <section>
                <p>You cannot edit or create props of the WrappedComponent instance,
                    because a React Component cannot edit the props it receives,
                    but you can change the props of the elements that are outputted from the render method.
                </p>
            </section>
            <section>
                <script src="https://gist.github.com/f0zze/e6d0dc70fd2ea90fdb0858c9cc646695.js"></script>
            </section>
            <section>
                <small>Modifying the React Elements tree outputted by render.</small>
                <p>
                    <script src="https://gist.github.com/f0zze/0568a06e296c4c9cf61cb69dbebcd3ba.js"></script>
                </p>
            </section>
            <section>
                <h3>Manipulating state</h3>
                <p>The HOC can read, edit and delete state of the WrappedComponent instance, and you can also add more
                    state if you need to</p>

            </section>
            <section>
                <h2>But</h2>
                <b>Don't do it!!!!</b>
            </section>
            <section>
                <h3>Naming</h3>
                <p>
                    When wrapping a component with an HOC you lose the original WrappedComponent’s name which might
                    impact you when developing and debugging.
                </p>
            </section>
            <section>
                <script src="https://gist.github.com/f0zze/296c1c667d7e58eb4937d03510996a0f.js"></script>
            </section>
            <section>
                <section>
                    <h2>Redux</h2>
                </section>
                <section>
                    <p>Redux attempts to make state mutations predictable by imposing certain restrictions on how and
                        when updates can happen.</p>
                </section>
                <section>
                    <h2>Three Principles</h2>
                    <ul>
                        <li>Single source of truth</li>
                        <li>State is read-only</li>
                        <li>Changes are made with pure functions</li>
                    </ul>
                </section>
                <section>
                    <section>
                        <h3>Single source of truth</h3>
                        <p>The state of your whole application is stored in an object tree within a single store.</p>
                    </section>
                    <section>
                        <ul>
                            <li>Easy to create universal/isomorphic apps</li>
                            <li>Easier to debug or inspect an application;</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h2>State is read-only</h2>
                    </section>
                    <section>
                        <p>
                            The only way to change the state is to emit an action, an object describing what
                            happened.
                        </p>
                    </section>
                </section>
                <section>
                    <section></section>
                    <section>
                        <p>To specify how the state tree is transformed by actions, you write pure reducers.</p>
                    </section>
                </section>
            </section>
        </section>
    </div>
</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>
    // More info about config & dependencies:
    // - https://github.com/hakimel/reveal.js#configuration
    // - https://github.com/hakimel/reveal.js#dependencies
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,

        dependencies: [
            {src: 'plugin/markdown/marked.js'},
            {src: 'plugin/markdown/markdown.js'},
            {src: 'plugin/notes/notes.js', async: true},
            {
                src: 'plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            }
        ]
    });
</script>
</body>
</html>
